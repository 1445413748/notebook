## 一、简介

### 1.1 分类

设计模式是对代码进行高层次抽象的总结，其中最出名的当属 *Gang of Four* (*GoF*) 的分类，他们将设计模式分类为 23 种经典的模式。

但是根据用途我们可以将设计模式分为三大类：

+ 创建型模式

  创建型模式对类的实例化过程进行了抽象，能够将模块中对象的创建和对象使用分离。

  包括：

  + 简单工厂模式（Simple Factory Pattern）

  + 工厂方法模式（Factory Method Pattern）

  + 抽象工厂模式（Abstract Factory Pattern）

  + 单例模式（Singleton Pattern）

  + 生成器模式（Builder Pattern）

  + 原型模式（Prototype Pattern）

+ 结构型模式

  结构型模式描述如何将类或者对象结合在一起形成更大的结构，结构型模式可以分为类结构型模式和对象结构型模式。

  + 外观模式
  + 适配器模式
  + 桥接模式
  + 代理模式
  + 装饰者模式
  + 享元模式

+ 行为型模式

  行为型模式是对不同对象之间划分责任和算法的抽象化，行为型模式不仅仅关注类和对象的结构，而且重点关注他们之间的相互作用。

  主要包括：

  + 职责链模式
  + 命令模式
  + 解释器模式
  + 迭代器模式
  + 中介者模式
  + 备忘录模式
  + 观察者模式
  + 状态模式
  + 策略模式
  + 模板方法模式
  + 访问者模式

### 1.2 六大原则

设计模式最好准寻以下六大原则。

#### 1.2.1 开闭原则

对外扩展开放，对修改关闭，我们编写的代码应该尽量在不修改原有代码的情况下进行扩展。

#### 1.2.2  里式替换原则

所有引用基类对象的地方能够透明地使用其子类的对象

#### 1.2.3 依赖倒置原则

抽象不应该依赖于具体类，具体类应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

#### 1.2.4 职责单一原则

每个类应该只有一个单一的功能。

#### 1.2.5 最少知道原则

两个类的工作保持独立，尽量不要相互通信。比如对数据库操作时，用户表应该由用户Class来进行维护，角色表应该由角色Class来维护，当要知道某用户是否有什么权限时，不应该把用户Class放到角色Class中来调用，更不应该将角色Class放到用户Class中来调用，应该在两者之间的做一个中间层，通过中间层来处理用户Class返回来的信息去操作角色Class，这样子就可以实现独立开发，提高维护。

#### 1.2.6 接口隔离原则

使用多个专用接口，而不是单一得到总接口。比如，需要一个飞行的接口，如果具体实现是鸟类，看似没有什么问题，但如果具体实现是飞行器，那具体实现不仅仅只有飞行接口，还具备载物接口，载物接口又分为载人和载物，所以一个具体实现类最好有多个可扩展的接口比较好。



## 二、创建型模式

