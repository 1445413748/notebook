### 事务定义

事务由一系列访问和更新操作组成的程序执行单元，这些操作要么都做，要么都不做，是不可分割的整体。

### MySQL中的事务

1. 事务以 `begin transaction` 开始，以 `commit` 或 `rollback` 语句结束

2. commit 语句：

   提交事务，此时事务正常结束，事务所做的修改操作都必须永久写入数据库。

3. rollback 语句

   回滚事务，此时事务非正常结束，事务所做的修改操作都必须撤销，即修改回旧值。数据库回退到事务开始前的状态。如果事务在还没有 commit 之前发生异常退出，系统会自动回滚这个事务。



#### 自动提交

MySQL 默认开启了自动提交模式，在该模式下，如果没有显式的开启一个事务，则每个 sql 语句都会被当成一个事务自动提交。

可以通过 `set autocommit = false` 关闭自动提交。需要注意的是，该命令是针对连接的，在一个连接中关闭了自动提交，不会影响到其他连接。



### 事务的ACID特性

#### 一、原子性

1. 定义

   指事务是一个不可分割的整体，对于一个事务中的全部操作，要么全部做，要么全不做。

2. 实现原理：undo log、redo log

   redo 是物理逻辑日志，记录了每条语句的修改记录，如在哪个数据页修改了哪个值，uodo 记录的是每条语句的反向修改记录，比如 insert 操作，在 undo log 中会记录 delete 这条记录。当事务执行过程中出现错误，
   
   + 如果事务还没有提交，则会通过 uodo log undo 事务的操作，恢复到事务执行前的状态
   + 如果事务已经提交，数据库的缓存还没有刷新到硬盘，则会通过 redo log redo 事务中的操作，执行到事务的 commit 语句

#### 二、持久性

1. 定义

   指事务一旦提交，它对数据库的修改是永久性的。

2. 实现原理：redo log

#### 三、隔离性

1. 定义

   指事务内部操作与其他事务是隔离的，并发执行的事务之间不能相互干扰，严格的隔离性，对应了务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。

   例如两个事务T1、T2同时对帐户A、B操作。如果T1读取的A是T2修改前的A，而读取的B是T2修改后的B，这就违反了隔离性，并可能导致数据错误

2. 实现原理

   可以通过锁机制使事务之间看起来像是串行化的

#### 四、一致性

1. 定义

   指事务结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。**数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。

2. 实现原理

   一致性是事务的目的，前面提到的原子性，隔离性，持久性都是为了保证一致性。

   所以，保持一致性包括：

   + 保证原子性，隔离性，持久性
   + 数据库自身保障：比如不能向一个域中插入其他域的值，列约束等
   + 应用层提供保证：这需要编写代码的人保证代码的鲁棒性，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。





### 事务并发执行产生的问题

#### 一、丢失修改（脏写）

比如并发两个事务同时从数据库读取同一数据分别修改再写入数据库

| 事务T1                 | 事务T2                 |
| ---------------------- | ---------------------- |
| read(A)                |                        |
|                        | read(A)                |
| A += 200<br />write(A) |                        |
|                        | A += 100<br />write(A) |

当 T1 提交后 T2 再提交，会使 T1 的修改丢失。



#### 二、不可重复读

事务 T1 读取某些数据后，事务 T2 对这些数据进行修改，当 T1 再次读取数据时，得到的数据跟前一次读取不同。

在事务 T1 的两次读取之间：

+ 事务 T2 更新了记录。则当 T1 第二次读取时，得到与前一次不同的记录值

#### 三、幻读

在事务 T1 的两次读取之间：

- 事务 T2 删除了部分记录。则当 T1 第二次读取时，发现其中的某些数据神秘地消失了
- 事务 T2 插入了一些数据。则当 T1 第二次读取时，发现神秘的多出一些记录

#### 四、脏读

事务T1 读到了 事务 T2 未提交事务修改过的数据

| 事务T1                                           | 事务T2   |
| ------------------------------------------------ | -------- |
|                                                  | read(A)  |
|                                                  | A += 100 |
| read(A)<br />use(A)  // 利用读到的 A进行其他操作 |          |
| commit                                           |          |
|                                                  | rollback |

如上面的表格，事务 T2 读取了 A（假设初始值为100），然后修改 A 为 200，事务 T1 读到的 A 为 200，对 A 进行其他操作后提交，可是事务 T2 因为某些原因进行了回滚，那么相当于 T1 操作了一个不存在的数，这种情况称为脏读。 

### SQL标准中的四种隔离级别

+ READ UNCOMMITTED：未提交读。
+ READ COMMITTED：已提交读。
+ REPEATABLE READ：可重复读。
+ SERIALIZABLE：可串行化。

SQL标准中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下：

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ UNCOMMITTED | √    | √          | √    |
| READ COMMITTED   | ×    | √          | √    |
| REPEATABLE READ  | ×    | ×          | √    |
| SERIALIZABLE     | ×    | ×          | ×    |

无论在那种隔离级别，脏写都不存在。



### MySQL中的四种隔离级别

不同数据库厂商对 SQL 标准的隔离级别支持不一样，比如 Oracle 只支持 `read committed` 和 `serializable`隔离级别。MySQL 虽然支持四种隔离级别，**但是与SQL标准中所规定的各级隔离级别允许发生的问题却有些出入，MySQL在REPEATABLEREAD隔离级别下，是可以禁止幻读问题的发生的**。



#### 设置隔离级别

+ 通过语句 `SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;`

  其中 level 可选：

  ```mysql
  level: {
  	REPEATABLE READ
  	| READ COMMITTED
  	| READ UNCOMMITTED
  	| SERIALIZABLE
  }
  ```

  + 使用GLOBAL关键字（在全局范围影响）：
    `SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;`
    则：
    1. 只对执行完该语句之后产生的会话起作用。
    2. 当前已经存在的会话无效。
  + 使用SESSION关键字（在会话范围影响）：
    `SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;`
    则：
    1. 对当前会话的所有后续的事务有效
    2. 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务。
    3. 如果在事务之间执行，则对后续的事务有效。
  + 上述两个关键字都不用（只对执行语句后的下一个事务产生影响）：
    `SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`
    则：
    1. 只对当前会话中下一个即将开启的事务有效。
    2. 下一个事务执行完后，后续事务将恢复到之前的隔离级别。
    3. 该语句不能在已经开启的事务中间执行，会报错的

+ 在启动 MySQL 时指定参数 `transaction-isolation` 的值。比方说我们在启动服务器时指定了`--transactionisolation=SERIALIZABLE`，那么事务的默认隔离级别就从原来的 `REPEATABLE READ` 变成了 `SERIALIZABLE`。

#### 查看隔离级别

```
mysql> SHOW VARIABLES LIKE 'transaction_isolation';

+-----------------------+-----------------+
| Variable_name | Value |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.02 sec)
```

或者使用更简便的写法：

```
mysql> SELECT @@transaction_isolation;

+-------------------------+
| @@transaction_isolation |
+-------------------------+
| REPEATABLE-READ |
+-------------------------+
1 row in set (0.00 sec)
```















### reference

https://www.cnblogs.com/kismetv/p/10331633.html