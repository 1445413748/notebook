### 面向切面编程

对于我们编写的类，如果都要调用相同的功能（如日志，安全检查），有两种实现的方法，第一种是在每一个类中重复编写实现该功能的代码，这对于少量的类完全可以实现，可是如果是几百上千个类，这就完全不可取了。另一种方法是将实现这个功能的代码集合在一个独立的类中，然后调用这个类，但是这样做的话我们其他的类都会和这个独立的类发生耦合，如果它发生了什么改动，那我们还是要在其他类中一个一个地修改。

而面向切面编程的出现，使我们可以仍然在一个定义通用功能，可以通过声明的方法定义这个功能要以什么方式在什么地方使用。在运行的时候，动态地将代码织入到指定的方法中，而且不影响我们原来编写的类。

### AOP术语

+ 切面（Aspect）

  一个特殊的类，是通知和切点的集合

+ 通知 \ 增强（Advice）

  切面的工作，其实就是你想要的方法，如日志记录，安全检查等。

  通知的五种类型：

  1. 前置通知（Before）：在目标方法调用之前调用
  2. 后置通知（After）：在目标方法调用之后调用，此时不会关心方法的输出值是什么
  3. 返回通知（After-returning）：在目标方法成功执行后调用
  4. 异常通知（After-throwing）：在目标方法抛出异常后调用通知
  5. 环绕通知（Around）：在目标方法调用前后执行自定义代码

+ 连接点（join point）

  我们定义的类中可以被增强的方法，注意不是切面类，而是调用通知的类。

+ 切点（pointcut）

  在类中有很多方法可以被增强，但在实际操作中，我们只想对类中某几个方法方法进行增强，这几个方法就称为切点。

### Spring中的AOP

spring AOP构建在动态代理基础之上，因此Spring AOP 只支持方法拦截。

Spring 使用 AspectJ 的切点表达式语言来定义切点

| AspectJ指示器 |                             描述                             |
| :-----------: | :----------------------------------------------------------: |
|     arg()     |            限制连接点匹配参数为指定类型的执行方法            |
|    @args()    |           限制连接点匹配参数由指定注解标注执行方法           |
|  execution()  |                   用于匹配连接点的执行方法                   |
|    this()     |        限制连接点匹配AOP代理的bean引用为指定类型的类         |
|    target     |            限制连接点匹配的目标对象为指定类型的类            |
|   @target()   | 限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解 |
|   within()    |                   限制连接点匹配指定的类型                   |
|   @within()   |              限制连接点匹配指定注解所标注的类型              |
|  @annotation  |                 限定匹配带有指定注解的连接点                 |

除了上面的指示器之外，Spring 还引入了 bean() 指示器。bean() 使用 bean ID 或 bean 名称作为参数来限制切点只匹配特定的 bean。

